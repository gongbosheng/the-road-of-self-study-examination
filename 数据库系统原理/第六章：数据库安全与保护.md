# 1 数据库完整性

## 1.1什么是数据库完整性

数据库完整性是指数据库中数据的**正确性**和**相容性**

## 1.2 完整性约束条件的作用对象

- 列级约束  
  - 包括对列的类型，取值范围，精度等的约束
- 元组约束
  - 指元组中各个字段之间的相互约束（开始日期要比结束日期早）
- 表级约束
  - 指若干元组，关系之间的联系的约束（参照完整性约束）

## 1.3 定义与实现完整性约束

- 实体完整性
- 参照完整性
- 用户定义完整性

**实体完整性**

- 每一个表只能定义一个主键
- 主键不能为空，必须能唯一标识表中的每一行记录
- 复合主键不能包含不必需要的多余列（不能为超码）
- 一个列名在符合主键的列表中只能出现一次

**参照完整性**

```sql
references table_name(index_col_name,...)
[on delete reference_option]
[on update reference_option]
```

- table_name   指定外键所参照的表名
- idnex_col_name  参照的列
- reference_option 策略（如果没有给的话默认为 restrict）
  - restrict  限制策略（拒绝删除更新）
  - cascade  级联策略（可以修改，但是要先删外键再删主键,如果直接删除主键，则所有外键数据也会被删除。）
  - set_null  置空策略（可以修改，如果要删除主键，需要把外键设置为null）
  - no action  不采取实施策略

```sql
--  为已经存在的表添加参照完整性约束
alter table orders add constraint fk_tb_orders_cust foreign key(cust_id) references cust(cust_id) on delete restrict on update restrict;

-- 创建表的时候直接添加完整性约束
mysql> create table orders(
order_id int not null auto_increment,
cust_id int not null,
order_product char(10) null,
order_product_type char(10) null,
order_date char(10) null,
order_amount char(10) null,
primary key(order_id),
constraint fk foreign key(cust_id) references cust(cust_id) on delete restrict on update restrict
);
-- 这里参照完整性约束虽然是在外码的表添加的，但是实际上约束的是主键，所以没有插入的约束，只有删除和更新的约束
```

**用户定义完整性约束**

- 非空约束  : not null

- check约束 : 如用户定义 sex 只能为 f

  ```sql
  check(expr)
  ```

## 1.4 命名完整性约束

```sql
constraint[symbo]
```

只能给基于表的完整性约束指定名字

无法给基于列的完整性约束指定名字

如果没有给出名字数据库会自动创建名字

命名完整性约束的方法就是在各种完整性约束的定义说明之前加上关键字 constraint 和该约束的名字。

具体实例可以参考1.3实例

## 1.5 更新完整性约束

使用 alter table 语句更新与列或表的各种约束，完整性约束不能直接修改，只能先删除，再添加。

```sql
alter table orders drop primary key;
alter table orders add primary key(order_id);

-- 如果在删除的时候告诉你无法删除因为atuo 列必须定义为键可以现修改列 的约束 再删除 然后添加完成后再修改回去。
```

# 2 触发器

## 2.1 什么是触发器

是用户定义在关系表上的一类由事件驱动的数据对象也是一种保证数据完整性的方法。

## 2.2 创建触发器

```sql
 create trigger trigger_name trigger_time trigger_event on table_name for each row trigger_body;
 
-- create trigger 创建触发器对象
-- trigger_name   触发器名称
-- trigger_time   触发时间
-- trigger_event  触发事件
-- on table_name  作用于那个表
-- for each row   固定写法 指定对于受触发器事件影响的每一行都要激活触发器的动作
-- tigger_body    触发器动作主体
```

实例：在数据库mysql_test的表cust中创建一个触发器customers_insert_trigger,用于每次向表 customers 插入一行数据时，将用户变量 str 的值 设置为 on customer added

```sql
 create trigger cust_insert_trigger after insert on cust for each row set @str = 'one cust adder!';
 
 select * from mysql_test.cust;
 
 select @str;
```

实例：在数据库mysql_test的表cust中创建一个触发器customers_insert_trigger,用于每次向表 customers 插入一行数据时，将用户变量 str 的值 设置为插入行的 id 号

```sql
 create trigger cust_insert_trigger after insert on cust for each row set @str = new.cust_id;
 
 -- 这里体现了 new 表的作用
```

实例：在数据库mysql_test的表cust中创建一个触发器cust_update_trigger,用于每次更新表 cust 时，将该表中的 city 列 的值设置为 cust_address 列的值。

```sql
create trigger cust_delete_trigger1 before update on cust for each row set  new.city = old.cust_address;

-- 这里为 update 的实例。
-- 原理其实是在更新之前通过old表，更改new表的值，在正在进行更新的时候，他会把这个new表的数据写入到实表中，这样就实现了如上的需求。
-- 更新不过是先删除再添加

-- 这里可以思考一下 sql 插入数据的原理，他并非直接插入，而是将要插入的数据写到一个 new 的虚表中,这里数据是存在内存的，实际写入到硬盘后，再将 new 表中数据的物理地址按照一定逻辑添加到实表中进行对应。这些都是这个操作引发的思考，并不能作准。
```

同一个表格只能有六个触发器，也就是说只能有一个 after insert

## 2.3 删除触发器

```sql
drop trigger if exists cust_insert_trigger;
```

## 2.3 使用触发器

- insert
  - 在 insert 触发器代码内，可引用一个名为 new 的虚拟表，来访问被插入的行。
  - 在 brefore insert 触发器中，new中的值可以被更新。
- delete
  - 在delete触发器代码内，可引用一个名为old的虚拟表，来访问被删除的行，需要注意的是，old 中的值全部是只读的，不能被更新。
- update
  - 在 update 触发器代码内，可引用一个名为 old 的虚拟表，来访问 update 语句执行前的值，也可以引用一个名为 new 的虚拟表来访问更新后的值。

# 3 安全性与访问控制

- 用户账号管理
- 账号权限管理

数据库的安全性是指保护数据库以防止不合法的使用而造成数据泄漏，更改或破坏，所以安全性对于任何一个DBMS来说都是至关重要的。

**查看用户**

```sql
select user from mysql.user;
```

**创建用户**

```sql
-- 创建用户明文口令
create user zhangsan@'localhost' identified by '123';

-- 获取 456 加密后的值
select password(456);

-- 创建用户密文密码
create user lisi@'localhost' identified by password '*531E182E2F72080AB0740FE2F2D689DBE0146E04';

-- 一起创建
reate user zhangsan@'localhost' identified by '123',lisi@'localhost' identified by password '*531E182E2F72080AB0740FE2F2D689DBE0146E04';
```

**删除用户**

```sql
drop user lisi@'localhost';
```

**修改用户账号**

```sql
rename user old_user to new_user;

--
rename user lisi@'localhost' to gongbosheng@'localhost';
```

**修改口令**

```sql
set password for user=password('pass');

-- 
set password for gongbosheng@'localhost' = password('123');
```

**用户授权**

```sql
-- 授予用 gongbosheng 在数据库 mysql_test 的表 cust 上拥有对 列 cust_id 和 cust_name 的 select 的权限，并能够对自己的权限进行分发。

grant select (cust_id,cust_name) on mysql_test.cust to gongbosheng@'localhost' identified by '123456' with grant option;

-- grant  授予权限语句
-- select 查询权限
-- (cust_id,cust_name) 指定列
-- on mysql_test.cust  指定表
-- to gongbosheng@'localhost' 权限属于那个用户
-- identified by '123456' 设置密码
-- with grant option; 允许对权限进行分发


-- 授予权限并创建用户
grant select,update on mysql_test.* to liming@'localhost' identified by '123' , huang@'localhost' identified by '456' ;


-- 授予用户创建用户的权限
grant create user on *.* to gongbosheng@'localhost';
```

**权限的回收**

```sql
-- 回收gongbosheng 用户创建用户的权限
revoke create user on *.* from gongbosheng@'localhost';
```

# 4 事务与并发控制

## 4.1 事务的概念

所谓事务时用户定义的一个数据操作序列，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位，事务中的操作一般是对数据的更新操作，包括增，删，改。

以 begin transaction 语句开始

以 commit（提交）语句或reollback（回滚）语句结束

## 4.2 事务的特征（ACID）

- 原子性（Atomicity）：事务不可分割的最小单位。
- 一致性（Consistency）：事务执行前，执行后，数据库都要保持一致。
- 隔离性（Isolation）：事务之间相互独立
- 持续性（Durability）：事务一旦提交对数据库的改变是永久的

## 4.3 并发操作问题

- 丢失更新
  - 事务 T1 T2 同时读入同一数据并加以修改， T2 的提交结果会破坏 T1 提交的结果。
- 不可重复读
  - 事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次的读取结果。
- 读"脏"数据
  - 事务 T1 修改数据后撤销，使得 T2 读取的数据与数据库中不一致。

## 4.4 封锁

封锁是最常用的并发控制技术

基本思想：需要时，事务通过向系统请求对他所希望的数据对象加锁，以确保他被非预期改变。

一个锁实质上就是允许或阻止一个事务对一个数据对象的存取特权

### 4.4.1 基本的封锁特征

- 排他锁（X锁），用于写操作，（一个数据库对象在一个事务执行时不允许任何其他的事务的进行）
- 共享锁（S锁），用于读操作，（一个数据库对象在事务读的时候，允许其他的事务来也来读，但是不允许其他事务来进行写操作。）

### 4.4.2 封锁的工作原理

- 若事务T对数据D加了X锁，则别的所有事务对数据D的锁请求都必须等待直到事务T释放锁
- 若事务T对数据D加了S锁，则别的事务还可对数据D请求S锁，而对数据D的X锁请求必须等待直到事务T释放锁
- 事务执行数据库操作时都要先请求相应的锁，即对读操作请求S锁，对更新请求X锁，这个过程一般是由DNMS在执行操作时自动隐含的进行。
- 事务一直占有获得的锁直到结果时释放。

### 4.4.3 封锁的粒度

- 我们通常以粒度来描述的封锁的数据单元的大小,DBMS可以决定不通粒度的锁，粒度越细，并发性越大，但软件复杂性和系统开销也就很大。

### 4.4.4 封锁的级别

- 封锁级别又称为一致性级别或隔离度
- 0级封锁：不重写其他非0级封锁事务的未提交的更新数据。（实用价值低）
- 1级封锁：不允许重写未提交的更新数据，防止了丢失更新发生。
- 2级封锁：既不重写也不读未提交的更新数据（防止读脏数据）
- 3级封锁：不读未提交的更新数据，不写任何（包括读操作）未提交的数据。

### 4.4.5 死锁和活锁

- 活锁：先来先服务
- 死锁：预防
  - 一次性锁请求
  - 锁请求排序
  - 序列化处理
  - 资源剥夺

### 4.4.6 可串行性

一组事务的一个调度就是它们的基本操作的一种排序。

在数据库系统中，可串行性就是并发执行的正确性准则，即当且当一组事务的并发执行调度是可串行化的，才认为他们是正确的。

### 4.4.7 两段封锁法（TWO-Phase Locking,2PL）

- 发展（Growing）或加锁阶段
- 收缩（Shrinking）或释放锁阶段

# 5 备份与恢复

## 5.1 数据库备份与恢复的概念

- 计算机硬件故障
- 计算机软件故障
- 病毒
- 人为误操作
- 自然灾害
- 盗窃

数据备份是指通过导出数据或者复制表文件的方式来制作数据库复本；数据库恢复则是当数据库出现故障或遭到破坏时，将备份的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态。数据库的恢复是以备份为基础的，他是与备份相对应的系统维护和管理操作。

## 5.2 备份数据的方法

```sql
select * from table_name into outfile 'file_name' export_options | into dumpfile 'file_name'

[fields
 	[terminated by 'string']
 	[[optionally] enclosed by 'char']
 	[escaped by 'char']   
    
]
[lines terminated by 'string']

-- select *  查询想要备份的数据
-- into outfile 'filename'  备份到指定的文件（不会紧挨着放置）
-- into dumpfile 'filename'  备份到指定的文件（dumpfile导出的备份文件里面所有数据行都会彼此紧挨着放置）
-- terminated by 'string'            指定分割字符
-- [optionally] enclosed by 'char'  指定包裹文件中字符值的符号
-- escaped by 'char'                指定转义字符
-- lines terminated by 'string'     指定数据行结束的标志
```

## 5.3 恢复数据的方法

```sql
load data infile 'file_name' into table table_name

[fields
 	[terminated by 'string']
 	[[optionally] enclosed by 'char']
 	[escaped by 'char']   
    
]
[lines terminated by 'string']

-- 注意恢复只会恢复给定表中存在的列
```

## 5.4 实例

备份数据库 mysql_test 中表 cust  的全部数据到 c 盘的 backup 目录下一个名为 backupfile.txt 的文件中。要求字段值如果是字符则用双引号标注，字段值之间用逗号隔开，每行以问号作为结束标指。然后，将备份后的数据导入一个 和 cust 表结构相同的空表 cust_copy 中。

```sql
 -- 备份
 select * from mysql_test.cust into outfile 'D:/backupfile.txt' fields
    -> terminated by ','
    -> optionally enclosed by ""
    -> lines terminated by '?';
    
-- 恢复
 load data infile 'D:/backupfile.txt' into table mysql_test.cust_copy fields
    -> terminated by ','
    -> optionally enclosed by ""
    -> lines terminated by '?';
```

