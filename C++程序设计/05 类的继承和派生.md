# 一、 类的继承和派生

## （1） 继承的概念

继承和派生是人们认识客观世界的过程。在程序设计方法中，人们追求代码复用(这是提高软件开发效率的重要手段),将继承和派生用于程序设计方法中，从而有了面向对象程序设计的重要特点。C+ +对代码复用有很强的支持，"继承" 就是支持代码复用的机制之一。

通过已有的类建立新类的过程，叫作类的派生。原来的类称为基类,也称为父类或一般类;新类称为派生类,也称为子类或特殊类。派生类派生自基类，或继承于基类，也可以说基类派生了派生类。派生机制是C++语言及面向对象程序设计方法的重要特征之一。派生类可以再作为基类派生新的派生类，由此基类和派生类的集合称作类继承层次结构。

使用基类派生新类时，除构造函数和析构函教外，基类的所有成员自动成为派生类的成员，包括基类的成员变量和成员函数。同时，派生类可以增加基类中没有的成员，这同样是指成员变量和成员函数。可以重新定义或修改基类中已有的成员，包括可以改变基类中成员的访问权限。当然派生类需要定义自己的构造函数和析构函数。

使用基类成员是一个重用的过程，在基类之上进行调整,不论是添加新成员还是改造已有的，都是扩充的过程。

若派生类中定义了一个与基类中同名的成员，则会出现基类与派生类有同名成员的情况，这是允许的。同名的成员既可以是成员变量，也可以是成员函数。这种情况下，若在派生类的成员函数中访问这个同名成员，或通过派生类对象访问这个同名成员时，除非特别指明，访问的就是派生类中的成员,这种情况叫"覆盖",即派生类的成员覆盖基类的同名成员。覆盖也称为重定义或是重写。对于成员函数来说，派生类既继承了基类的同名成员函数,又在派生类中重写了这个成员函数。这称为函数重定义，也称为同名隐藏。"隐藏"的意思是指，使用派生类对象调用这个名字的成员函数时，调用的是派生类中定义的成员函数，即隐藏了基类中的成员函数。

```c++
#include <iostream>

using namespace std;

class Base
{
    private:
        int a;
    public:
        Base(int a);
        void print();
};

Base::Base(int a):a(a){};

void Base::print()
{
    cout << a << endl; 
}

class Derived: public Base
{
    private:
        int a;
    public:
        Derived(int x, int y);
        void print();
};

void Derived::print()
{
    cout << a << endl;
}


Derived::Derived(int x, int y):Base(x)
{
    a = y;
}

int main()
{
    Derived ss1(20,10);
    ss1.print();        // 10  就近原则 但是如果子类没有 print 这个函数， 则会自动调用基类 print 这个方法 打印的也是 Base 的 a 值
    ss1.Base::print();  // 20
}
```

## （2） 派生类的定义与大小

派生类对象中包含基类成员变量，而且基类成员变量的存储位置位于派生类对象新增的成员变量之前。派生类对象占用的存储空间大小，等于基类成员变量占用的存储空间大小加上派生类对象自身成员变量占用的存储空间大小。

对象占用的存储空间包含对象中各成员变量占用的存储空间。出于计算机内部处理效率的考虑，为变量分配内存时，会根据其对应的数据类型，在存储空间内对变量的起始地址进行边界对齐。可以使用sizeof( )函数计算对象占用的字节数。对象的大小与普通成员变量有关，与成员函数和类中的静态成员变量无关，即普通成员函数、静态成员函数、静态成员变量、静态常量成员变量等均对类对象的大小没有影响。

空类也可以作为基类，也就是说，空类可以派生子类。例如，下列语句定义了空基类的派生类。

```c++
class emptyClass();
class subemptyCLass:public emptyClass{};

// 主要作用为预留接口
```

## （3） 继承关系的特殊性

如果基类有友元类或友元函数，则其派生类不会因继承关系而也有此友元类或友元函数。如果基类是某类的友元，则这种友元关系是被继承的。

即被派生类继承过来的成员函数，如果原来是某类的友元函数，那么它作为派生类的成员函数仍然是某类的友元函数。

总之，基类的友元不一定是派生类的友元;基类的成员函数是某类的友元函数，则其作为派生类继承的成员函数仍是某类的友元函数。

如果基类中的成员是静态的，则在其派生类中，被继承的成员也是静态的,即其静态属性随静态成员被继承。

如果基类的静态成员是公有的或是保护的，则它们被其派生类继承为派生类的静态成员。访问这些成员时，通常用“ <类名>::<成员名>”的方式引用或
调用。无论有多少个对象被创建，这些成员都只有一个拷贝，它为基类和派生类的所有对象所共享。

```c++
#include <iostream>

using namespace std;

// 继承关系的特殊性

class Base
{
    public:
        static int a;
};


class Derived:public Base
{
    public:
        Derived();
};

Derived::Derived()
{
    a++;
}

int Base::a = 0;

int main()
{
    Base A;
    Derived B;
    cout << A.a << endl;  // 1
}
```

## （4） 有继承关系的类之间的访问

派生类和基类中都可以定义自己的成员变量和成员函数，派生类中的成员函数可以访问基类中的公有成员变量，但不能直接访问基类中的私有成员变量。也就是说，不能在派生类的函数中，使用”基类对象名.基类私有成员函数(实参)”，或是“基类对象名.基类私有成员变量”，或是”基类名::基类私有成员”的形式访问基类中的私有成员。

在类的派生层次结构中，基类的成员和派生类新增的成员都具有类作用域。二者的作用范围不同，是相互包含的两个层，派生类在内层，基类在外层。如果派生类声明了一个和基类某个成员同名的新成员，派生的新成员就隐藏了外层同名成员，直接使用成员名只能访问到派生类的成员。如果派生类中声明了与基类成员函数同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏。如果要访问被隐藏的成员，就需要使用基类名和作用域分辨符来限定。

## （5） protected 访问范围说明符

定义类时，类成员可以使用 protected 访问范围说明符进行修饰，从而成为“保护成员”。保护成员的访问范围比私有成员的访问范围大，能访问私有成员的地方都能访问保护成员。此外,基类中的保护成员可以在派生类的成员函数中被访问。

在基类中，一般都将需要隐藏的成员说明为保护成员而非私有成员。将基类中成员变量的访问方式修改为protected后，在派生类中可以直接访问。

## （6） 多重继承

C+ +允许从多个类派生一个类，即- -个派生类可以同时有多个基类。这称为多重继承。相应地,从一个基类派生一个派生类的情况，称为单继承或单重继承。一个类从多个基类派生的一般格式如下:

```c++
#include <iostream>

using namespace std;

class A
{
    public:
        int a;
};

class B
{
    public:
        int b;
};

class C: public A, public B
{
    public:
        void getAB();
};

void C::getAB()
{
    a = 1;
    b = 2;
    cout << a << b << endl;
}

int main()
{
    C ss1;
    ss1.getAB();
}
```

派生类继承了基类名1、基类名2、.... 基类名6的所有成员变量和成员函数，各基类名前面的继承方式说明符用于限制派生类中的成员对该基类名中成员的访问权限，其规则与单继承情况一样。

多重继承情况下如果多个基类间成员重名时，按如下方式进行处理:对派生类而言，不加类名限定时默认访问的是派生类的成员;而要访问基类重名成员时，要通过类名加以限定。

如果派生类中新增了同名成员，则派生类成员将隐藏所有基类的同名成员。使用“派生类对象名.成员名”或“派生类对象指针-> 成员名”的方式可以唯一标识和访问派生类新增成员。这种情况下，不会产生二义性。

如果派生类中没有新增同名成员，当满足访问权限时，使用“派生类对象名.成员名”或“派生类对象指针->成员名”方式时，系统无法判断到底是调用哪个基类的成员，从而产生二义性。为了避免二义性，必须通过基类名和作用域分辨符来标识成员。

当要访问派生类对象中的某个变量时，添加"基类.:"作为前缀，指明需要访问从哪个基类继承来的，从而可以排除二义性。

# 二、 访问控制

设计继承类时，需要使用继承方式说明符指明派生类的继承方式。继承方式说明符可以是public(公有继承)、private(私有继承) 或protected(保护继承)

## （1） 公有继承

| 各成员                 | 派生类中         | 基类与派生类外   |
| ---------------------- | ---------------- | ---------------- |
| 基类的公有成员         | 直接访问         | 直接访问         |
| 基类的保护成员         | 直接访问         | 调用公有函数访问 |
| 基类的私有成员         | 调用公有函数访问 | 调用公有函数访问 |
| 从基类继承的公有成员   | 直接访问         | 直接访问         |
| 从基类继承的保护成员   | 直接访问         | 调用公有函数访问 |
| 从基类继承的私有成员   | 调用公有函数访问 | 调用公有函数访问 |
| 派生类中定义的公有成员 | 直接访问         | 直接访问         |
| 派生类中定义的保护成员 | 直接访问         | 调用公有函数访问 |
| 派生类中定义的私有成员 | 直接访问         | 调用公有函数访问 |

## （2） 类型兼容规则

类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代，也称为赋值兼容规则。

在公有派生的情况下，有以下3条类型兼容规则。

- 派生类的对象可以赋值给基类对象。
- 派生类对象可以用来初始化基类引用。
- 派生类对象的地址可以赋值给基类指针，即派生类的指针可以赋值给基类的指针。

上述3条规则反过来是不成立的。例如，不能把基类对象赋值给派生类对象。在进行替代之后，派生类对象就可以作为基类的对象使用了，**但只能使用从基类继承的成员。**

```c++
#include <iostream>

using namespace std;

class A 
{
    public:
        int a;
};
class B:  public A {};

int main()
{
    B b;
    b.a = 10;
    A a = b;
    cout << a.a << endl;
}
```

## （3） 私有继承

|                | 第一级派生类中   | 第二级派生类中 | 基类与派生类外 |
| -------------- | ---------------- | -------------- | -------------- |
| 基类的公有成员 | 直接访问         | 不可访问       | 不可访问       |
| 基类的保护成员 | 直接访问         | 不可访问       | 不可访问       |
| 基类的私有成员 | 调用公有函数访问 | 不可访问       | 不可访问       |

## （4） 保护继承

保护继承中，基类的公有成员和保护成员都以保护成员的身份出现在派生类中，而基类的私有成员不可以直接访问。这样，派生类的其他成员可以直接访问从基类继承来的公有和保护成员，但在类外通过派生类的对象无法直接访问它们。

# 三、 派生类的构造函数和析构函数

## （1） 构造函数和析构函数

派生类并不继承基类的构造函数，所以需要在派生类的构造函数中调用基类的构造函数，以完成对从基类继承的成员变量的初始化工作。具体来说，派生类对象在创建时，除了要调用自身的构造函数进行初始化外，还要调用基类的构造函数初始化其包含的基类成员变量。

**在执行一个派生类的构造函数之前，总是先执低基类的构造函数。**派生类对象消亡时，先执行派生类的析构函数，再执行基类的析构函数。

定义派生类构造函数的一般格式如下：

```c++
name::name(int args): Base1(args), Base2(args){};
```

派生类对象的初始化是由基类和派生类的构造函数共同实现的。

## （2） 复制构造函数

对于一个类，如果程序中没有定义复制构造函数，则编译器会自动生成一个隐含的复制构造函数，这个隐含的复制构造函数会自动调用基类的复制构造函数，对派生类新增的成员对象执行复制。

如果要为派生类编写复制构造函数，一般也需要为基类相应的复制构造函数传递参数，但并不是必须的。

## （2） 多继承中构造函数与析构函数

派生类构造函数执行的一般次序如下:

- 调用基类构造函数，调用顺序按照它们**被继承时声**明的顺序**(从左向右)**。
- 对派生类新增的成员变量初始化，调用顺序按照它们在类中声明的顺序。
- 执行派生类的构造函数体中的内容。

构造函数初始化列表中基类名、对象名之间的次序无关紧要，它们各自出现的顺序可以是任意的，无论它们的顺序怎样安排，基类构造函数的调用和各个成员变量的初始化顺序都是确定的。

```c++
#include <iostream>

using namespace std;

class A
{
    public:
        A();
        ~A();
};

A::A()
{
    cout << "A in" << endl;
}

A::~A()
{
    cout << "A out" << endl;
}

class B
{
    public:
         B();
         ~B();
};

B::B()
{
    cout << "B in" << endl;
}

B::~B()
{
    cout << "B out" << endl;
}

class C : public A, public B
{
    public:
        C();
        ~C();
};

C::C()
{
    cout << "C in" << endl;
}

C::~C()
{
    cout << "C out" << endl;
}

int main()
{
    C a;  
    /* 
    A in
    B in
    C in
    C out
    B out
    A out
    */
}
```

# 四、 类之间的关系

## （1） 类之间的关系

使用已有类编写新的类有两种方式:继承和组合。这也形成类和类之间的两种基本关系:继承关系和组合关系(组合关系也就是第三章第六节提到的包含关系)，

- 继承关系也称为"isa"关系或“是”关系。(具有传递性)
- 组合关系也称为"has a"关系或“有”关系，表现为封闭类，即一个类以另一个类的对象作为成员变量。

## （2） 封闭类的派生

已知基类是封闭类，在创建派生对象时，构造函数的执行顺序是 对象成员构造函数 - 基类构造函数 - 派生类构造函数。



## （3） 互相包含的类

在处理相对复杂的问题而需要考虑类的组合时，很可能遇到两个类相互引用的情况，这种情况称为循环依赖。举例如下:

```c++
#include <iostream>

using namespace std;

class B;

class A
{
    public:
        int a;
        void f(B b);
};

class B
{
    public:
        int b;
        void f(A a);
};

void A::f(B b)
{
    cout << b.b << endl;
}

void B::f(A a)
{
    cout << a.a << endl;
}

int main()
{
    A a;
    B b;
    a.a = 1;
    b.b = 2;
    a.f(b);
    b.f(a);
}
```

# 五、 多层次的派生

在C++中，派生可以是多层次的。例如，类CStudent派生类CGraduatedStudent, 而后者又可以派生CDoctorStudent等。总之，类A派生类B，类B可以再派生类C，类C又能够派生类D，以此类推。在这种情况下，称类A是类B的直接基类，类B是类C的直接基类,类A是类C的间接基类。当然，类A也是类D的间接基类。在定义派生类时，只需写直接基类，不需写间接基类。派生类沿着类的层次自动向上继承它所有的直接和间接基类的成员。在C++中，类之间的继承关系具有**传递性**。

派生类的成员包括派生类自己定义的成员、直接基类中定义的成员及所有间接基类中定义的全部成员。

当生成派生类的对象时，会从最顶层的基类开始逐层往下执行所有基类的构造函数，最后执行派生类自身的构造函数;当派生类对象消亡时，会先执行自身的析构函数，然后自底向上依次执行各个基类的析构函数。

```c++
#include <iostream>

using namespace std;

class A
{
    public:
        int a;
};

class B: public A{};

class C: public B{};

int main()
{
    C c;
    c.a = 1;
    cout << c.a  << endl;
}
```

# 六、 基类和派生类指针的相互转换

在公有派生的情况下，因为派生类对象也是基类对象,所以派生类对象可以赋给基类对象。对于指针类型，可以使用基类指针指向派生类对象，也可以将派生类的指针直接赋值给基类指针。但即使基类指针指向的是一-个派生类的对象，也不能通过基类指针访问基类中没有而仅在派生类中定义的成员函数。

```c++
#include <iostream>

using namespace std;

class A
{
    public:
        int a;
};

class B: public A{};

int main()
{
    B *b;
    b->a = 1;
    A *a = b;
    cout << a->a << endl;
}
```

