# 一、 多态的基本概念

## （1） 多态

多态分为编译时多态和运行时多态。**编译时多态主要是指函数的重载(包括运算符的重载)**。 对重载函数的调用，在编译时就可以根据实参确定应该调用哪个函数，因此称为**编译时多态**。编译阶段的多态称为**静态多态**。

运行时多态则和**继承、虚函数**等概念有关。本章中提及的多态主要是指运行时多态。运行阶段的多态称为**动态多态**。

程序编译阶段都早于程序运行阶段，所以**静态绑定称为早绑定**，**动态绑定称为晚绑定**。静态多态和动态多态的区别，只在于在什么时候将函数实现和函数调用关联起来，是在编译阶段还是在运行阶段，即函数地址是早绑定的还是晚绑定的。

在类之间**满足赋值兼容的前提**下，实现动态绑定必须满足以下两个条件: (公有派生)

- 必须声明虚函数。
- 通过基类类型的引用或者指针调用虚函数。

## （2） 虚函数

所谓“虚函数”，就是在函数声明时前面加”了**virtual**关键字的成员函数。virtual关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。**静态成员函数不能是虚函数。包含虚函数的类称为“多态类”**

声明虚函数成员的一般格式如下:

```c++
virtual 函数返回值类型函数名(形参表);
```

在类的定义中使用virtual关键字来限定的成员函数即成为虚函数。再次强调一下，**虚函数的声明只能出现在类定义中的函数原型声明时，不能在类外成员函数实现的时候。**

派生类可以继承基类的同名函数,并且可以在派生类中重写这个函数。如果不使用虚函数，当使用派生类对象调用这个函数，且派生类中重写了这个函数时，则调用派生类中的同名函数,即“隐藏”了基类中的函数。

当然，如果还想调用基类的函数，只需在调用函数时，在前面加上**基类名及作用域限定符**即可。

关于虚函数，有以下几点需要注意。

- 虽然将虚函数声明为内联函数不会引起错误，但因为内联函数是在编译阶段进行静态处理的，而对虚函数的调用是动态绑定的，所以虚函数一般不声明为内联函数。
- 派生类重写基类的虚函数实现多态，要求函数名、参数列表及返回值类型要完全相同。
- 基类中定义了虚函数，在派生类中该函数始终保持虚函数的特性。
- 只有类的非静态成员函数才能定义为虚函数，静态成员函数和友元函数不能定义为虚函数。
- 如果虚函数的定义是在类体外,则只需在声明函数时添加virtual关键字,定义时不加virtual关键字。
- 构造函数不能定义为虚函数。最好也不要将operator=定义为虚函数, 因为使用时容易混淆。
- 不要在构造函数和析构函数中调用虚函数。在构造函数和析构函数中，对象是不完整的，可能会出现未定义的行为。
- 最好将基类的析构函数声明为虚函数。

```c++
#include <iostream>

using namespace std;

class A
{
    public:
        virtual void getA();
};

void A::getA()
{
    cout << "A" << endl;
}


class B : public A
{
    public:
        void getA();
};

void B::getA()
{
    cout << "B" << endl;
}

int main()
{
    B b;
    A *a1 = &b;
    A &a2 = b;
    A a3 = b;
    a1->getA();  // 指针形式
    a2.getA();   // 引用形式
    a3.getA();   // 对象形式无法调用虚函数
    a1->A::getA();  // 类名限定符
}
```

析构函数中和构造函数中调用虚函数采用的是动态联编。

## （3） 通过基类的指针实现多态

声明虚函数后，派生类对象的地址可以赋值给基类指针，也就是基类指针可以指向派生类对象。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时系统并不确定要执行的是基类还是派生类的虚函数;而当程序运行到该语句时，如果基类指针指向的是一个基类对象,则调用基类的虚函数;如果基类指针指向的是一个派生类对象，则调用派生类的虚函数。

## （4） 通过基类引用实现多态

通过基类指针调用虚函数时可以实现多态，通过基类的引用调用虚函数的语句也是多态的。即通过基类的引|用调用基类和派生类中同名、同参数表的虚函数时，若其引用的是一-个基类的对象，则调用的是基类的虚函数;若其引用的是一个派生类的对象，则调用的是派生类的虚函数。

## （5） 多态的实现原理

多态的关键在于通过基类指针或引用调用一一个虚函数时，编译阶段不能确定到底调用的是基类还是派生类的函数，运行时才能确定。

# 二、 多态的实例

```c++
#include <iostream>

using namespace std;

class A
{
    public:
        virtual void a();
        virtual void b();
};

void A::a()
{
    cout << "A.a" << endl;
}

void A::b()
{
    cout << "A.b" << endl;
}

class B: public A
{
    public:
        void a();
        void b();
};

void B::a()
{
    cout << "B.a" << endl;
}

void B::b()
{
    cout << "B.b" << endl;
}

class C: public A
{
    public:
        void a();
        void b();
};

void C::a()
{
    cout << "C.a" << endl;
}

void C::b()
{
    cout << "C.b" << endl;
}


int main()
{
    B b;
    C c;
    A *a = &b;
    a->a();
    a->b();
    a = &c;
    a->a();
    a->b();
}
```

# 三、 多态的使用


在普通成员函数(静态成员函数、构造函数和析构函数除外)中调用其他虚成员函数也是允许的，并且是多态的。

```c++
#include <iostream>

using namespace std;

// 多态的使用

class A
{
    public:
        void a();
        virtual void b();
};


void A::a()
{
    b();
};  

void A::b()
{
    cout << "A" << endl;
}


class B:public A
{
    public:
        void b();
};

void B::b()
{
    cout << "B" << endl;
}

int main()
{
    B b;
    A *a = &b;
    a->b(); // B  在成员函数中调用虚函数
}

```

不仅能在成员函数中调用虚函数，还可以在构造函数和析构函数中调用虚函数，**但这样调用的虚函数不是多态的。**

# 四、 虚析构函数

如果一个基类指针指向的对象是用new运算符动态生成的派生类对象，那么释放该对象所占用的空间时，如果仅调用基类的析构函数，则只会完成该析构函数内的空间释放，不会涉及派生类析构函数内的空间释放，容易造成内存泄漏。声明虚析构函数的一般格式如下:

```
virtual ～类名( );
```


虚析构函数没有返回值类型，没有参数，所以它的格式非常简单。如果一个类的析构函数是虚函数，则由它派生的所有子类的析构函数也是虚析构函数。使用虚析构函数的目的是为了在对象消亡时实现多态。

```c++
#include <iostream>

using namespace std;

// 虚析构函数

class A
{
    public:
        virtual ~A();  // 析构函数是否为虚函数印象着 B 是否析构
        // ~A();
};

A::~A()
{
    cout << "A" << endl;
}

class B: public A
{
    public:
        ~B();
};

B::~B()
{
    cout << "B" << endl;
}

int main()
{
    A *a = new B;
    delete a;
}

```

# 五、 纯虚函数和抽象类

纯虚函数的作用相当于一个统一的接口形式，表明在基类的各派生类中应该有这样的一个操作，然后在各派生类中具体实现与本派生类相关的操作。纯虚函数是声明在基类中的虚函数，没有具体的定义，而由各派生类根据实际需要给出各自的定义。

声明纯虚函数的一般格式如下:

```c++
virtual void fun( )=0;
```

纯虚函数没有函数体，参数表后要写“=0”。派生类中必须重写这个函数。按照纯虚函数名调用时，执行的是派生类中重写的语句，即调用的是派生类中的版本。

包含纯虚函数的类称为抽象类。因为抽象类中有尚未完成的函数定义，所以它不能实例化一个对象。抽象类的派生类中，如果没有给出全部纯虚函数的
定义，则派生类继续是抽象类。直到派生类中给出全部纯虚函数定义后，它才不再是抽象类，也才能实例化一个对象。虽然不能创建抽象类的对象，但可以定义抽象类的指针和引用。这样的指针和引用可以指向并访问派生类的成员，这种访问具有多态性。

```c++
#include <iostream>

using namespace std;

// 纯虚函数和抽象类

class A
{
    public:
        virtual void a() = 0;
};

class B: public A
{
    public:
        void a();
};

void B::a()
{
    cout << "B" << endl;
}


int main()
{
    // A a; // 抽象类不能直接实例化
    A *a = new B;
    a->a();
}
```

# 六、 虚基类

为了避兔产生二义性，C+ +提供虚基类机制使得在派生类中，继承向一个间接基类的成员仅保留一个版本。

定义虚基类的一般格式如下：

```c++
class 派生类名 : virtual public 基类名
{
  派生类体
}
```

实例

```c++
#include <iostream>

using namespace std;

// 虚基类

class A
{
    public:
        int a;
};


class B: virtual public A{};

class C: virtual public A{};

class D: public B, public C {};

int main()
{
    D a;
    a.a = 10;
    cout << a.a << endl;
}
```

