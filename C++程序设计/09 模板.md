# 一、 函数模板

## （1） 函数模板的概念

设计程序中的函数时，可能会遇到函数中参数的类型有差异，但需要实现的功能类似的情形。函数重载可以处理这种情形。重载函数的参数表中，可以写不同类型的参数，从而可以处理不同的情形。

为了提高效率，实现代码复用，C+ +提供了一种处理机制，即使用函数模板。函数在设计时并不使用实际的类型，而是使用虚拟的类型参数。这样可以不必为每种不同的类型都编写代码段。当用实际的类型来实例化这种函数时,将函数模板与某个具体数据类型连用。编译器将以函数模板为样板，生成一个函数，即产生了模板函数,这个过程称为函数模板实例化。函数模板实例化的过程由编译器完成。程序设计时并不给出相应数据的类型，编译时，由编译器根据实际的类型进行实例化。

```c++
#include <iostream>

using namespace std;

template <typename T>

T abs(T x)
{
    return x;
}

int main()
{
    double a = 1.11;
    int b = 2;
    cout << abs(a) << " " <<   abs(b) << endl;
}
```

## （2） 函数模板的示例

虽然函数模板的使用形式与函数类似，但二者有本质的区别，主要表现在以下3个方面。

- 函数模板本身在编译时不会生成任何目标代码，只有当通过模板生成具体的函数实例时才会生成目标代码。
- 被多个源文件引用的函数模板，应当连同函数体一同放在头文件中，而不能像普通函数那样只将声明放在头文件中。
- 函数指针也只能指向模板的实例，而不能指向模板本身。

函数模板中还可以带多个类型参数。例如，下面这个函数模板的写法是合法的。

```c++
#include <iostream>

using namespace std;

template <typename T1， typename T2>

T abs(T1 x, T2 y)
{
    return x + y;
}

```

## （3） 函数和函数模板的调用语句的匹配顺序

函数与函数模板也是允许重载的。在函数和函数模板名字相同的情况下，一条函数调用语句到底应该被匹配成对哪个函数或哪个模板的调用呢? C++编译器遵循以下先后顺序。

- 先找参数完全匹配的普通函数(不是由模板实例化得到的模板函数)。
- 再找参数完全匹配的模板函数。
- 然后找实参经过自动类型转换后能够匹配的普通函数。
- 如果上面的都找不到，则报错。

```c++
#include <iostream>

using namespace std;

template <typename T>

T abs(T x)             // 模版函数
{
    return x;
}

int abs(int x)         // 普通函数
{
    return x + 1;
} 

int abs(int y, int x)  // 自动类型转换后匹配
{
    return x + y;
}

int main()
{
    double a = 1.11;
    int b = 2;
    cout << abs(a) << " " <<   abs(b) << " " << abs(a,b) << endl;
}
```

# 二、 类模版

## （1） 类模板的概念

通过类模板，可以实例化一一个个的类。继承机制也是在一系列的类之 间建立某种联系，这两种涉及多个类的机制是有很大差异的。类是相同类型事物的抽象，有继承关系的类可以具有不同的操作。而模板是不同类型的事物具有相同的操作，实例化后的类之间没有联系，相互独立。

不能使用类模板来直接生成对象，因为类型参数是不确定的，必须先为模板参数指定"实参”,即模板要"实例化”后,才可以创建对象。也就是说，当使用类模板创建对象时，要随类模板名给出对应于类型形参或普通形参的具体实参，格式如下:

```c++
类模板名<模板参数表>对象名....对象名n;
```

或是

```c++
类模板名<模板参数表>对象名1(构造函数实参)...对象名n(构造函数实参);
```

编译器由类模板生成类的过程称为类模板的实例化。由类模板实例化得到的类称为模板类。要注意的是，与类型形参相对应的实参是类型名。

```c++
#include <iostream>

using namespace std;

template <class T1, class T2>
  


class A
{
    public:
        T1 a;
        T2 b;
};

template <int i>

class B
{
    public:
  	    int a[i];   // 使数组 a 长度动态可变化
};


int main()
{
    A<int,char> a;
    a.a = 1;
    a.b = 'c';
    cout << a.b << a.a << endl;
  	B<1> b;
}
```

注： 为了创建类模版，在类模版声明格式为

```c++
template <类模版参数> class 类名 {};
```

并不因为其中有函数模版而定义。

## （2） 类模板与继承

类之间允许继承，类模板之间也允许继承。具体来说，类模板和类模板之间、
类模板和类之间可以互相继承，它们之间的常见派生关系有以下4种情况: .

- 普通类继承模板类。
- 类模板继承普通类。
- 类模板继承类模板。
- 类模板继承模板类。

根据类模板实例化的类即是模板类。



```c++
#include <iostream>

using namespace std;

class Z {};

template <class T>

class A: public Z   //  普通类派生类模板
{
    public:
        T a;
};

class B: public A<int> {}; // 模版类派生普通类


class C: public A<int> {}; // 模版类派生类模板

template <class P, class T>

class D: public A <T>  // 类模版派生类模板
{
    public:
        P c;
};

int main()
{
    A<int> a1;
    B a2;
    C a3;
    D<char, int> a4;

}
```

