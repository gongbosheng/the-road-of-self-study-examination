# 一、 构造函数

对于 C++ 中基本数据类型的变量，可以声明全局变量和函数内部的局部变量。

- 全局变量 ： 如果程序员在声明变量的时候没有进行初始化， 则系统自动为其初始化为 0。这个工作在程序启动时自动完成。
- 局部变量 ： 系统不进行自动初始化，所以它的初值需要程序员给定。如果程序员没有设定，则是一个随机值。



## （1） 普通构造函数

为了对对象进行初始化，C+ +提供了一种称为构造函数的机制，用于对对象进行初始化,实际上是用来为成员变量赋初值的。

构造函数是类中的特殊成员函数，它属于类的一部分。给出类定义时，由程序员编写构造函数。如果程序员没有编写类的任何构造函数，则由系统自动添加一个不带参数的构造函数。

声明对象后，可以使用new运算符为对象进行初始化，此时调用的是对象所属类的构造函数。构造函数的作用是完成对象的初始化工作，用来保证对象的初始状态是确定的。在对象生成时，系统自动调用构造函数，用户在程序中不会直接调用构造函数。

构造函数允许重载。

```c++
#include <iostream>

using namespace std;


class classname
{
    public:
        int year, mouth;
        classname();
        classname(int);
        classname(int, int);
    private:
        int c;
};

classname::classname(): year(1), mouth(2){   // 函数初始化列表形式
    cout << year << mouth << endl;
};

classname::classname(int a) : year(a), mouth(2){};

classname::classname(int a, int b) : year(a), mouth(b){};

int main()
{
	classname *ss = new classname();
    delete ss;
}
```

对象数组初始化

```c++
classname A[3] = {classname(1),classname(2),classname(3)}
```



`*p` 只是开辟了空间，并不会调用构造函数。 `A[3]` 则会调用



## （2） 复制构造函数

复制构造函数是构造函数的一-种，也称为拷贝构造函数。它的作用是使用一一个已存在的对象去初始化另一个正在创建的对象。例如，类对象间的赋值是由复制构造函数实现的。

复制构造函数只有一个参数，参数类型是本类的引用。复制构造函数的参数可以是const引用，也可以是非const引用。一个类中可以写两个复制构造函数, 一个函数的参数是const引用，另一个函数的参数是非const引用。这样，当调用复制构造函数时，既能以常量对象(初始化后值不能改变的对象)作为参数，也能以非常量对象作为参数去初始化其他对象。对于类A而言，复制构造函数的原型如下(格式一)

```c++
A::A(const A&)
```

或是如下

```c++
A::A(A &)
```

实例

```c++
#include <iostream>

using namespace std;


class classname
{
    public:
        int year, mouth;
        classname();
        classname(int);
        classname(int, int);
        classname(classname &c);
        classname(const classname &c);
        ~classname();
    private:
        int c;
};

classname::classname(): year(1), mouth(2){
    cout << year << mouth << endl;
};

classname::classname(int a) : year(a), mouth(2){};

classname::classname(int a, int b) : year(a), mouth(b){};

classname::classname(classname &c):year(c.year), mouth(c.mouth){};

classname::classname(const classname &c):year(c.year), mouth(c.mouth){};


classname::~classname()
{
    cout << "析构函数" << endl;
}

int main()
{
	classname *ss = new classname();
    delete ss;  // 当对象消亡的时候自动调用 析构函数

    classname s1(5,6);
    classname s2=s1;
    classname s3(s1);
    cout << s2.year << endl;
}
```

自动调用复制构造函数的情况有以下三种

- 当用一个对象去初始化本类的另一个对象时，会调用复制构造函数。例如，使用下列形式的说明语句时，即会调用复制构造函数。

```c++
类名 对象名2(对象名1);
类名 对象名2=对象名1;
```

- 如果函数F的参数是类A的对象，那么当调用F时，会调用类A的复制构造函数。换句话说，作为形参的对象,是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。（作为形参）
- 如果函数的返回值是类A的对象，那么当函数返回时，会调用类A的复制构造函数。也就是说，作为函数返回值的对象是用复制构造函数初始化的，而调用复制构造函数时的实参，就是retrun语句所返回的对象。（作为返回值）

注意，在复制构造函数的参数表中，加上const是更好的做法。这样复制构造函数才能接收常量对象作为参数，即才能以常量对象作为参数去初始化别的对象。

# 二、 析构函数

与构造函数一样，析构函数也是成员函数的一-种，它的名字也与类名相同,但要在类名前面加一个"~”字符，以区别于构造函数。析构函数没有参数，也没有返回值。一个类中有且仅有一个析构函数，如果程序中没有定义析构函数，则编译器自动生成默认的析构函数。析构函数不可以多于一个，不会有重载的析构函数。默认析构函数的函数体为空。

创建对象时自动调用构造函数，那么，什么时候调用析构函数呢?可想而知，在对象消亡时自动调用析构函数。析构函数的作用是做一-些善后处理的工作。例如，如果在创建对象时使用new运算符动态分配了内存空间，则在析构函数中应该使用delete释放掉这部分占用的空间，保证空间可再利用。

```c++
#include <iostream>

using namespace std;


class classname
{
    public:
        int year, mouth;
        classname();
        classname(int);
        classname(int, int);
        ~classname();
    private:
        int c;
};

classname::classname(): year(1), mouth(2){
    cout << year << mouth << endl;
};

classname::classname(int a) : year(a), mouth(2){};

classname::classname(int a, int b) : year(a), mouth(b){};

classname::~classname()
{
    cout << "析构函数" << endl;
}

int main()
{
	classname *ss = new classname();
  delete ss;  // 当对象消亡的时候自动调用 析构函数
}
```



# 三、 类的静态成员

## （1） 静态变量

与C语言一样, 可以使用static说明自动变量。根据定义的位置不同，分为静态全局变量和静态局部变量。

全局变量是指在所有花括号之外声明的变量，其作用域范围是全局可见的，即在整个项目文件内都有效。使用static修饰的全局变量是静态全局变量,其作用域有所限制，仅在定义该变量的源文件内有效，项目中的其他源文件中不能使用它。

块内定义的变量是局部变量，从定义之处开始到本块结束处为止是局部变量的作用域。使用static修饰的局部变量是静态局部变量，即定义在块中的静态变量。静态局部变量具有局部作用域，但却具有全局生存期。

静态局部变量具有局部作用域，但却具有全局生存期。也就是说，静态局部变量在程序的整个运行期间都存在，它占据的空间- -直到程序结束时才释放，但仅在定义它的块中有效，在块外并不能访问它。

静态变量均存储在全局数据区，静态局部变量只执行一-次初始化。 如果程序未显式给出初始值，则相当于初始化为0;如果显式给出初始值，则在该静态变量所在块第一次执行时完成初始化。

## （2） 类的静态成员

类的静态成员有两种:

- 静态成员变量
- 静态成员函数。

在类体内定义类的成员时，在前面添加static关键字后，该成员即成为静态成员类的静态成员被类的所有对象共享，不论有多少对象存在，静态成员都只有一份
保存在公用内存中。对于静态成员变量，各对象看到的值是一样的。定义类静态成员变量时，在类定义中声明静态成员变量，然后必须在类体外定义静态成员变量的初值。这个初值不能在类体内赋值。

给静态成员变量赋初值的格式如下:

```c++
类型类名::静态成员变量=初值;
```

注意,在类体外为静态成员变量赋初值时，前面不能加static关键字，以免和一般的静态变量相混淆。在类体外定义成员函数时，前面也不能加static关键字。

访问静态成员时，成员前面既可以用类名作前缀,也可以使用对象名或对象指针作前缀)这与访问类成员时仅能使用对象名或对象指针作前缀是不同的。

一般格式如下三种：

```c++
classname::staticval
  
obj.staticval
  
obj->staticval
```

类的静态成员函数没有this指针，不能在静态成员函数内访问非静态的成员，即通常情况下，**类的静态成员函数只能处理类的静态成员变量。静态成员函数内也不能调用非静态成员函数。**

对于普通成员变量，每个对象有各自的一份,而静态成员变量只有一份，被同类所有对象共享。

```c++
#include <iostream>

using namespace std;


class classname
{
    public:
        static int n;
        int year, mouth;
        classname();
        classname(int);
        classname(int, int);
        classname(classname &c);
        classname(const classname &c);
        ~classname();
        void add();
    private:
        int c;
};

classname::classname(): year(1), mouth(2){
    cout << year << mouth << endl;
};

classname::classname(int a) : year(a), mouth(2){};

classname::classname(int a, int b) : year(a), mouth(b){};

classname::classname(classname &c):year(c.year), mouth(c.mouth){};

classname::classname(const classname &c):year(c.year), mouth(c.mouth){};

void classname::add()
{
    cout << "n ++" <<endl;
    n++;
};

classname::~classname()
{
    cout << "析构函数" << endl;
}

int classname::n = 0;

int main()
{
	classname *ss = new classname();
    delete ss;  // 当对象消亡的时候自动调用 析构函数

    classname s1(5,6);
    classname s2=s1;
    cout << s2.year << endl;

    s1.add();
    s2.add();
    cout << s1.n << endl;

}
```



# 四、 变量及对象的生存期及作用域

## （1） 变量的生存期和作用域

变量的生存期是指变量所占据的内存空间由分配到释放的时期。变量有效的范围称为其作用域。全局变量是程序中定义在所有函数(包括main函数)之外的任何变量，其作用域是程序从变量定义到整个程序结束的部分。这意味着全局变量可以被所有定义在全局变量之后的函数访问。全局变量及静态变量分配的空间在全局数据区，它们的生存期为整个程序的执行期间。

而局部变量，如在函数内或程序块内说明的变量，被分配到局部数据区，如栈区等。这种分配是临时的，一旦该函数体或程序块运行结束，所分配的空间就会被撤销。局部变量的生存期从被说明处开始，到所在程序块结束处结束。

对于静态变量，如果没有进行初始化，系统会自动初始化为0。局部变量如果没有进行初始化，则其值是不确定的。,

使用new运算符创建的变量具有动态生存期。从声明处开始，直到用delete运算符释放存储空间或程序结束时，变量生存期结束。

## （2） 类对象的生存期和作用域

类的对象在生成时调用构造函数，在消亡时调用析构函数，在这两个函数调用之间即是对象的生存期。



# 五、 常量成员和常引用成员

# 六、 成员对象和封闭类

# 七、 友元

# 八、 this 指针